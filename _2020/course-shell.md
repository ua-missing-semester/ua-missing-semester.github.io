---
layout: lecture
title: "Огляд курсу + оболонка"
date: 2020-01-13
ready: true
video:
  aspect: 56.25
  id: Z56Jmr9Z34Q
---

# Мотивація

Як комп'ютерні науковці, ми знаємо, що комп'ютери чудово допомагають у вирішенні 
повторюваних завдань. Однак надто часто ми забуваємо, що це стосується 
як нашого _використання_ комп'ютера, так і обчислень, 
які ми хочемо, щоб наші програми виконували. У нас є широкий спектр інструментів, 
які дозволяють нам бути продуктивнішими й 
розв'язувати складніші проблеми при роботі з будь-якою комп'ютерною 
задачею. Та багато з нас використовують лише невелику частину цих інструментів; ми 
знаємо достатньо магічних заклинань напам'ять, щоб впоратися, і бездумно 
копіюємо-вставляємо команди з інтернету, коли застрягаємо.

Цей курс є спробою вирішити це.

Ми хочемо навчити вас використовувати на повну ваші відомі інструменти, показати 
вам нові інструменти, які можна додати до вашого набору, і, сподіваємось, вбудувати в вас деякий 
ентузіазм для дослідження (і, можливо, створення) більшої кількості інструментів самостійно. 
Ось що, на нашу думку, відсутнє у більшості навчальних планів з комп'ютерних наук.

# Структура курсу

Курс складається з 11 одногодинних лекцій, кожна з яких зосереджена на 
[певній темі](/2020/). Лекції в основному незалежні, 
хоча з часом ми будемо передбачати, що ви знайомі 
з матеріалом попередніх лекцій. У нас є нотатки до лекцій 
онлайн, але на курсі буде багато матеріалу (наприклад, у 
вигляді демонстрацій), який може не бути в нотатках. Ми будемо записувати 
лекції та розміщувати записи онлайн.

Ми намагаємося охопити багато матеріалу за допомогою лише 11 одногодинних 
лекцій, тому лекції досить щільні. Щоб дати вам час 
ознайомитися з матеріалом у вашому власному темпі, кожна лекція включає 
набір вправ, які направляють вас через ключові моменти лекції.
Після кожної лекції ми проводимо години консультацій, де ми будемо присутні, щоб 
допомогти відповісти на будь-які ваші питання. Якщо ви відвідуєте курс 
онлайн, ви можете надсилати нам питання на 
[missing-semester@mit.edu](mailto:missing-semester@mit.edu).

Через обмежений час, який у нас є, ми не зможемо розглянути всі інструменти 
з тією ж деталізацією, яку міг би надати повноцінний курс. Де це можливо, ми 
намагатимемося вказати вам на ресурси для детальнішого вивчення інструменту 
чи теми, але якщо щось особливо приверне вашу увагу, не 
соромтеся звернутися до нас і попросити про поради!

# Тема 1: Оболонка

## Що таке оболонка?

У сучасних комп'ютерів є різноманітні інтерфейси для введення команд; 
різноколірні графічні інтерфейси користувача, голосові інтерфейси, 
а також AR/VR є скрізь. Це чудово для 80% випадків використання, але 
вони часто фундаментально обмежені в тому, що дозволяють вам робити — 
ви не можете натиснути кнопку, якої немає, або вимовити голосову команду, 
яка не була запрограмована. Щоб повністю використовувати інструменти, які 
надає ваш комп'ютер, ми повинні повернутися до старої школи й перейти до текстового 
інтерфейсу: Оболонки.

Майже всі платформи, які ви можете мати під рукою, мають оболонку у тій чи 
іншій формі, і багато з них мають кілька оболонок на ваш вибір. 
Хоча вони можуть відрізнятися деталями, в їхній основі вони всі приблизно 
однакові: вони дозволяють вам запускати програми, передавати їм вхідні дані та перевіряти 
їхній вихід у напівструктурований спосіб.

У цій лекції ми зосередимося на Bourne Again SHell, або "bash" 
у скороченні. Це одна з найбільш широко використовуваних оболонок, і її синтаксис 
схожий на те, що ви бачитимете в багатьох інших оболонках. Щоб відкрити _промпт_ 
(де ви можете вводити команди), спершу вам потрібен _термінал_. 
Ваш пристрій, ймовірно, був поставлений із встановленим терміналом, або ви можете встановити
його дуже легко.

## Використання оболонки

Коли ви запускаєте свій термінал, ви побачите _промпт_, який часто виглядає приблизно так:

```console
missing:~$ 
```

Це основний текстовий інтерфейс до оболонки. Він повідомляє вам, що ви 
знаходитесь на машині `missing` і що ваш "поточний робочий каталог", 
або місце, де ви зараз знаходитесь, — це `~` (скорочення від "домашній"). Символ `$` каже вам, 
що ви не користувач root (про це пізніше). На цьому промпті ви 
можете ввести _команду_, яка потім буде інтерпретована оболонкою. 
Найпростіша команда — це виконання програми:

```console
missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 
```

Тут ми виконали програму `date`, яка (можливо, не дивно) 
виводить поточну дату та час. Після цього оболонка просить нас про іншу 
команду для виконання. Ми також можемо виконати команду з _аргументами_:

```console
missing:~$ echo hello
hello
```

У цьому випадку ми сказали оболонці виконати програму `echo` з 
аргументом `hello`. Програма `echo` просто виводить свої аргументи. 
Оболонка аналізує команду, розділяючи її пробілами, а потім 
запускає програму, вказану першим словом, передаючи кожне наступне 
слово як аргумент, до якого програма може отримати доступ. Якщо ви хочете передати 
аргумент, який містить пробіли або інші спеціальні символи (наприклад, 
каталог під назвою "My Photos"), ви можете або взяти аргумент в лапки `'` 
або `"` (`"My Photos"`), або використовувати обернену скісну риску `\` 
(`My\ Photos`).

Але як оболонка знає, як знайти програми `date` або `echo`? 
Ну, оболонка — це програмне середовище, як Python або Ruby, 
і тому вона має змінні, умовні конструкції, цикли та функції (наступна 
лекція!). Коли ви запускаєте команди у своїй оболонці, ви насправді пишете 
невеликий фрагмент коду, який інтерпретує ваша оболонка. Якщо оболонка отримує 
команду, яка не відповідає жодному з її програмних ключових слів, вона 
звертається до _змінної середовища_ під назвою `$PATH`, яка перелічує, 
які каталоги оболонка повинна шукати програми, коли їй дають 
команду:


```console
missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Коли ми запускаємо команду `echo`, оболонка бачить, що вона повинна виконати 
програму `echo`, а потім шукає файл із такою назвою в розділеному `:` списку 
каталогів у `$PATH`. Коли вона знаходить його, вона 
запускає його (за умови, що файл є _виконавчим_; про це пізніше). Ми можемо 
дізнатися, який файл виконується для даної назви програми, використовуючи 
програму `which`. Ми також можемо повністю обійти `$PATH`, вказавши 
_шлях_ до файлу, який ми хочемо виконати.

## Навігація в оболонці

Шлях в оболонці — це розділений список каталогів; розділений `/` 
в Linux і macOS та `\` в Windows. У Linux і macOS шлях `/` 
є "коренем" файлової системи, під яким знаходяться всі каталоги та файли, 
тоді як у Windows є один корінь для кожного дискового розділу (наприклад, 
`C:\`). Ми загалом припускаємо, що ви використовуєте файлову систему Linux 
у цьому курсі. Шлях, який починається з `/`, називається _абсолютним_ шляхом. 
Якийсь інший шлях є _відносним_ шляхом. Відносні шляхи відносяться до 
поточного робочого каталогу, який ми можемо побачити за допомогою команди `pwd` і 
змінити за допомогою команди `cd`. У шляху `.` належить до поточного 
каталогу, а `..` - до його батьківського каталогу:

```console
missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
```

Зверніть увагу, що наш оболонковий запит постійно інформував нас про поточний
робочий каталог. Ви можете налаштувати свій запит так, щоб він показував вам всі
різні корисні інформації, про які ми поговоримо в наступній лекції.

Зазвичай, коли ми запускаємо програму, вона працює в поточній
каталог, якщо ми не скажемо іншого. Наприклад, вона зазвичай
шукає файлы там, і створює нові файли там, якщо потрібно.

Щоб побачити, що знаходиться в даному каталозі, ми використовуємо команду `ls`:
```console
missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
```

Якщо директорія не задана як перший аргумент, `ls` виведе
вміст поточного каталогу. Більшість команд приймають прапори й
опції (прапори зі значеннями), що починаються з `-`, для зміни їх
поведінки. Зазвичай, запуск програми з прапором `-h` або `--help`
виводить текст довідки, який повідомляє вам, які прапори
й опції доступні. Наприклад, `ls --help` каже нам:

```
  -l                         use a long listing format
```

```console
missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
```

Це дає нам багато додаткової інформації про кожен файл або директорію
присутній. По-перше, `d` на початку рядка говорить нам, що
`missing` це директорія. Потім йдуть три групи по три символи
(`rwx`). Вони вказують, які права власника файлу
(`missing`), власника групи (`users`), і всіх інших відповідно
мають на відповідний елемент. `-` вказує на те, що дана основна відомість не
має даного дозволу. Вище, лише власник має дозвіл
змінювати (`w`) директорію `missing` (тобто, додавати/видаляти файли в ній). Щоб
увійти в директорію, користувач повинен мати "пошук" (представлений "виконанням":
`x`) права на цю директорію (і її батькі). Щоб перелічити її
вміст, користувач повинен мати читання (`r`) права на цю директорію. Для
файлів дозволи є такими, як ви очікуєте. Зверніть увагу, що майже всі
файли в `/bin` мають встановлений дозвіл `x` для останньої групи,
"всі інші", так що будь-хто може виконувати ці програми.

Деякі інші корисні програми, про які варто знати на цьому етапі, це `mv` (для
перейменування/переміщення файлу), `cp` (для копіювання файлу), і `mkdir` (для створення нового
директорія).

Якщо ви коли-небудь захочете _більше_ інформації про аргументи програми, вхідні дані,
вихідні дані, або як вона працює в цілому, спробуйте програму `man`. Вона
приймає як аргумент назву програми, і показує вам її _мауал
_сторінка__. Натисніть `q` щоб вийти.

```console
missing:~$ man ls
```

## Connecting programs

В оболонці програми мають два основних "потоки", пов'язані з ними:
їхній вхідний потік і вихідний потік. Коли програма намагається
зчитати вхідні дані, вона зчитує з вхідного потоку, а коли вона друкує
щось, вона друкує до свого вихідного потоку. Зазвичай вхід даних для програми
й вихід — це ваш термінал. Тобто, ваша клавіатура як вхід і
ваш екран як вихід. Однак, ми також можемо перенастроїть ці потоки!

Найпростіша форма перенаправлення — це `< file` та `> file`. Вони дозволяють вам
перенастроїти вхідний і вихідний потоки програми відповідно до файлу:

```console
missing:~$ echo hello > hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat < hello.txt
hello
missing:~$ cat < hello.txt > hello2.txt
missing:~$ cat hello2.txt
hello
```

Як показано в наведеному вище прикладі, `cat` - це програма, яка кон`cat`енує
файли. Коли вона отримує імена файлів в якості аргументів, вона друкує вміст кожного з
файлів послідовно у свій вихідний потік. Але коли `cat` не отримує жодних
аргументів, вона друкує вміст зі свого вхідного потоку у свій вихідний потік (як
у третьому прикладі вище).

Ви також можете використовувати `>>` для додавання до файлу. Головним чином,
перенаправлення вводу/виводу використовується для використання _труб_. Оператор `|`
дозволяє вам "ланцюжком" з'єднати програми так, що вихід одного є
вхідними даними іншого:

```console
missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
```

Ми детальніше розглянемо, як використовувати переваги труб
на лекції з питань обробки даних.

## Універсальний та потужний інструмент

На більшості систем, схожих на Unix, один користувач є особливим: користувач "root". Ви, можливо,
бачили його в списках файлів звище. Користувач root перебуває над (майже)
усіма обмеженнями доступу і може створювати, читати, оновлювати та видаляти будь-які
файли в системі. Зазвичай ви не входите у свою систему як
користувач root, оскільки занадто легко нехотячки зламати щось.
Замість цього ви будете використовувати команду `sudo`. Як же його назва має на увазі, це
дозволяє вам "робити" щось "як su" (скорочено "супер користувач", або "root").
Коли ви отримуєте помилки заборони доступу, це зазвичай означає, що вам потрібно щось зробити як root. Але переконайтеся, що ви спочатку двічі перевірили, що ви дійсно хотіли це зробити таким способом!

Є одна річ, для якої вам потрібно бути root, щоб зробити це, це запис в систему файлів `sysfs`, 
змонтовану в `/sys`. `sysfs` відображає ряд параметрів ядра в якості
файлів, так що ви можете легко переналаштовувати ядро на льоту без
спеціалізованих інструментів. **Зверніть увагу, що sysfs не існує на Windows або macOS.**

Наприклад, яскравість екрана вашого ноутбука відображається через файл
названий `brightness` нижче

```
/sys/class/backlight
```

Записавши значення в цей файл, ми можемо змінити яскравість екрана.
Вашим першим інстинктом може бути щось на зразок:

```console
$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 > brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
```

Ця помилка може здивувати. Адже ми запустили команду з
`sudo`! Це важлива річ, яку треба знати про оболонку. Операції
як `|`, `>`, і `<` виконуються _оболонкою_, а не окремою
програмою. `echo` та інші не "знають" про `|`. Вони просто читають з
їх входу та записують на їх вихід, що б це не було. В такому випадку
_shell_ (котра аутентифікована як ваш користувач) намагається
відкрити файл яскравості для запису, перед тим як встановити це як `sudo
echo` вихід, але йому перешкоджають зробити це, оскільки оболонка не
запущена як root. З використанням цих знань, ми можемо обійти це:

```console
$ echo 3 | sudo tee brightness
```

Оскільки програма tee відкриває файл /sys для запису, 
і _вона_ працює як root, усі дозволи виходять як потрібно. 
Ви можете керувати всілякими цікавими та корисними речами через /sys, такими як 
стан різних системних LED-діодів (ваш шлях може відрізнятися):

```console
$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
```

# Наступні кроки

На цей момент ви вже знаєте достатньо про оболонку, щоб виконувати
основні задачі. Ви повинні вміти навігуватися, щоб знайти файли, що
цікавлять, і використовувати основну функціональність більшості програм. У наступної
лекції ми будемо говорити про те, як виконувати та автоматизувати більш складні
завдання за допомогою оболонки та багатьох зручних програм командного рядка
там.

# Вправи

Всі заняття в цьому курсі супроводжуються серією вправ. Деякі дають
вам конкретне завдання, тоді як інші відкриті, наприклад "спробуйте використати X і Y
програми". Ми настійно рекомендуємо вам їх відпрацювати.

Ми не писали рішень для вправ. Якщо у вас щось не виходить
зокрема, не соромтеся надіслати нам електронний лист, в якому описано, що ви спробували до
цього пункту, і ми спробуємо вам допомогти.

 1. Для цього курсу вам потрібно використовувати оболонку Unix, таку як Bash або ZSH. Якщо ви
   на Linux або macOS, вам нічого спеціального робити не треба. Якщо ви на
   Windows, вам потрібно переконатися, що ви не використовуєте cmd.exe або PowerShell;
   ви можете використовувати [підсистему Windows для
   Linux](https://docs.microsoft.com/en-us/windows/wsl/) або віртуальну машину Linux, щоб використовувати інструменти командного рядка у стилі Unix. Щоб переконатися, що ви працюєте
   в підхожій оболонці, ви можете спробувати команду `echo $SHELL`. Якщо воно говорить
   щось на зразок `/bin/bash` або `/usr/bin/zsh`, це означає, що ви використовуєте
   правильну програму.
 1. Створіть новий каталог під назвою `missing` в `/tmp`.
 1. Дізнайтеся про програму `touch`. Програма `man` - ваш друг.
 1. Використовуйте `touch`, щоб створити новий файл під назвою `semester` в `missing`.
 1. Запишіть наступне у цей файл, по одному рядку на раз:
    ```
    #!/bin/sh
    curl --head --silent https://missing.csail.mit.edu
    ```
    Перший рядок може бути складним для реалізації. Корисно знати, що
    `#` починає коментар в Bash, і `!` має спеціальне значення навіть всередині
    подвійно-цитованих (`"`) рядків. Bash обробляє одинарно-цитовані рядки (`'`)
    інакше: вони виконають задачу в цьому випадку. Див. Bash
    [цитати](https://www.gnu.org/software/bash/manual/html_node/Quoting.html)
    керівництво для отримання додаткової інформації.
 1. Спробуйте виконати файл, тобто введіть шлях до сценарію (`./semester`)
   в оболонку і натисніть enter. Зрозумійте, чому це не спрацювало
   консультуючись з виводом `ls` (підказка: подивіться на біти дозволу
   файлу).
 1. Запустіть команду, явно відкривши інтерпретатор `sh`, і віддавши йому
   файл `semester` як перший аргумент, тобто `sh semester`. Чому це
   працює, а `./semester` - ні?
 1. Дізнайтеся про програму `chmod` (наприклад, використовуйте `man chmod`).
 1. Використовуйте `chmod`, щоб зробити можливим запуск команди `./semester`, а не
   вводити `sh semester`. Як ваша оболонка знає, що файл повинен
   бути інтерпретований за допомогою `sh`? Див. цю сторінку про
   [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) для отримання більш
   інформації.
 1. Використовуйте `|` та `>` для запису дати "останньої зміни", виведеної
   `semester` у файл під назвою `last-modified.txt` у вашому домашньому
   каталозі. 
 1. Напишіть команду, яка видає рівень живлення акумулятора вашого ноутбука або
   температуру процесора вашого настільного комп'ютера з `/sys`. Примітка: якщо ви користувач macOS,
   ваша операційна система не має sysfs, тому ви можете пропустити цю вправу.
